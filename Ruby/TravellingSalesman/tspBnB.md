# Solving the Travelling Salesman Problem with Branch and Bound

## What is the Travelling Salesman Problem?

- The **travelling salesman problem** is a mathematical problem in which one tries to find the shortest route that passes through each of a set of points once and only once
- It is similar to a salesman having to go to all of the houses in a neighborhood in the shortest way
- **There is no perfect solution for the TSP, just as there is no perfect solution to any problem in computer science;** there are only the solutions that are best for the environment they are meant to work in.
- One of the many ways to approach the TSP is the **branch and bound method**

## The Branch and Bound Method

Let's look at the following graph:

```mermaid
graph TD
  A((A)) --- B((B))
  A --- C((C))
  A --- D((D))
  A --- E((E))
  B --- C
  B --- D
  B --- E
  C --- D
  C --- E
  D --- E
  ```

- You have to visit all of the nodes in this graph, starting with node 1
- All of the possible ways of doing this are shown in the following tree:

```mermaid
graph TD
  A1((1)) --> A2((2))
  A1 --> A3((3))
  A1 --> A4((4))
  A1 --> A5((5))

  A2 --> A23((3))
  A2 --> A24((4))
  A2 --> A25((5))

  A23 --> A234((4))
  A23 --> A235((5))
  A24 --> A243((3))
  A24 --> A245((5))
  A25 --> A253((3))
  A25 --> A254((4))

  A3 --> A32((2))
  A3 --> A34((4))
  A3 --> A35((5))

  A32 --> A324((4))
  A32 --> A325((5))
  A34 --> A342((2))
  A34 --> A345((5))
  A35 --> A352((2))
  A35 --> A354((4))

  A4 --> A42((2))
  A4 --> A43((3))
  A4 --> A45((5))

  A42 --> A423((3))
  A42 --> A425((5))
  A43 --> A432((2))
  A43 --> A435((5))
  A45 --> A452((2))
  A45 --> A453((3))

  A5 --> A52((2))
  A5 --> A53((3))
  A5 --> A54((4))

  A52 --> A523((3))
  A52 --> A524((4))
  A53 --> A532((2))
  A53 --> A534((4))
  A54 --> A542((2))
  A54 --> A543((3))
```

>**Note:** This tree doesn't include the last node of each path because it is obvious what it will be after you have visited 4 of the nodes.

- The most obvious way to find the shortest path between all of the nodes is to go through every possible path recursively until you reach the leaf nodes, add up the costs, and find the path of least cost
- However, this is very time-consuming, so it is better for a permutation problem than for an optimization problem
- Branch and bound, however, optimizes this solution by avoiding exploring paths that are estimated to lead to high cost
- The branch and bound method gauges the cost of a path by using certain heuristics known as "bounds"
- Whenever it gauges a path to be too costly, it will "prune" off that branch of the tree; in other words, it will not pursue that path down to a leaf node

### Parts of branch and bound

1. **State space tree:** The state space tree is a tree where each node corresponds to a partial tour. It is shown above.
2. **Branching:** Child nodes in a state space tree are generated by adding on unvisited nodes to generate possible paths.
3. **Cost:** Branch and bound assigns a cost to each visited node in the state space tree. This cost is an estimate of the lower bound of the total tour cost from that node.
4. **Bounding:** If the cost of a node is greater than the currently known minimum cost of a node, then that node is **pruned** (not explored further).
5. **Cost priority queue:** Nodes of the state space tree are stored in a priority queue. Nodes with the least estimated cost are at the top of the queue and are popped out first. This creates the order in which nodes are explored.

### Steps of the Branch and bound method

```txt
1. Start at a root node, typically from city `0`, with an empty or partial path.
2. Calculate a Lower Bound:
    2.1 Estimate the minimum possible cost to complete the tour from the current node.
    2.2 Example: Use the two smallest outgoing edges for each unvisited city to calculate the lower bound.

3. Branch:
    3.1 Extend the current path by visiting each unvisited city.
    3.2 For each new path, calculate:
        3.2.1 New cost: Add the cost of the edge to the new city.
        3.2.2 New lower bound: Estimate the minimum remaining cost to complete the tour.

4. Bound (Prune):
    4.1 If the path's lower bound is greater than or equal to the best known complete path cost, prune it. This avoids exploring paths that cannot lead to an optimal solution.

5. Use a Priority Queue (Min-Heap):
    5.1 Always explore the node with the lowest lower bound next. The priority queue ensures the most promising partial solutions are expanded first.

6. Repeat Until Complete:
    6.1 When a full tour is found, update the best known cost.
    6.2 Continue expanding and pruning nodes in the queue until all nodes are either pruned or fully explored.
```
